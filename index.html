<!DOCTYPE html>
<html>
  <head>
    <title>Decompilation Status</title>
    <style>
      body {
        background: #202020;
        color: #f0f0f0;
        font-family: sans-serif;
      }

      h1 {
        text-align: center;
      }

      .main {
        width: 800px;
        max-width: 100%;
        margin: auto;
      }

      #search {
        width: 100%;
        box-sizing: border-box;
        background: #303030;
        color: #f0f0f0;
        border: 1px #f0f0f0 solid;
        padding: 0.5em;
        border-radius: 0.5em;
      }

      #search::placeholder {
        color: #b0b0b0;
      }

      #listing {
        width: 100%;
        border-collapse: collapse;
        font-family: monospace;
      }

      tr[data-address]:hover {
        background: #404040 !important;
      }

      tr[data-address]:nth-child(odd of :not([hidden])), #listing > thead th {
        background: #282828;
      }

      tr[data-address]:nth-child(even of :not([hidden])) {
        background: #383838;
      }

      table#listing {
        border: 1px #f0f0f0 solid;
        table-layout: fixed;
      }

      #listing > thead th {
        padding: 0.5em;
        user-select: none;
        text-align: left;
      }

      #listing > thead th[data-col="address"],
      #listing > thead th[data-col="recomp"] {
        /* enough for "0x" and 8 digit address */
        width: 10ch;
      }

      #listing > thead th[data-col="diffs"],
      #listing > thead th[data-col="matching"] {
        width: 8ch;
      }

      #listing > thead th > div {
        display: flex;
        column-gap: 0.5em;
      }

      #listing > thead th > div > span {
        cursor: pointer;
      }

      #listing > thead th > div > span:hover {
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      #listing > thead th:last-child > div {
        /* Draw the sort triangle to the left of the last column. */
        flex-direction: row-reverse;
        justify-content: right;
      }

      .diffneg {
        color: #FF8080;
      }

      .diffpos {
        color: #80FF80;
      }

      .diffslug {
        color: #8080FF;
      }

      .identical {
        font-style: italic;
        text-align: center;
      }

      sort-indicator {
        user-select: none;
      }

      .filters {
        align-items: top;
        display: flex;
        font-size: 10pt;
        justify-content: space-between;
        margin: 0.5em 0 1em 0;
      }

      .filters > fieldset {
        /* checkbox and radio buttons v-aligned with text */
        align-items: center;
        display: flex;
      }

      .filters > fieldset > input, .filters > fieldset > label {
        cursor: pointer;
      }

      .filters > fieldset > label {
        margin-right: 10px;
      }

      table.diffTable {
        border-collapse: collapse;
      }

      table.diffTable:not(:last-child) {
        /* visual gap *between* diff context groups */
        margin-bottom: 40px;
      }

      table.diffTable td, table.diffTable th {
        border: 0 none;
        padding: 0 10px 0 0;
      }

      table.diffTable th {
        /* don't break address if asm line is long */
        word-break: keep-all;
      }

      diff-display[data-option="0"] th:nth-child(1) {
        display: none;
      }

      diff-display[data-option="0"] th:nth-child(2),
      diff-display[data-option="1"] th:nth-child(2) {
        display: none;
      }

      label {
        user-select: none;
      }

      #pageDisplay > button {
        cursor: pointer;
        padding: 0.25em 0.5em;
      }

      #pageDisplay select {
        cursor: pointer;
        padding: 0.25em;
        margin: 0 0.5em;
      }

      p.rowcount {
        align-self: flex-end;
        font-size: 1.2em;
        margin-bottom: 0;
      }

      tr[data-diff]:not([hidden]) {
        contain: paint;
      }

      tr[data-diff] > td {
        border: 1px #f0f0f0 solid;
        border-bottom: 0px none;
        display: table-cell;
        padding: 0.5em;
        word-break: break-all !important;
      }

      tr[data-diff] > td > div.no-diff {
        font-style: italic;
        text-align: center;
      }

      tr[data-address] > td[data-col="name"]:hover {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-style: dotted;
      }

      tr[data-address] > td:not(data-col="name"]) {
        white-space: nowrap;
      }

      tr[data-address] > td {
        border-top: 1px #f0f0f0 solid;
        display: table-cell;
        padding: 0.5em;
        vertical-align: top;
        white-space: nowrap;
      }

      tr[data-address] > td[data-col="name"] {
        white-space: wrap;
        word-break: break-all !important;
      }

      tr[data-address] > td:last-child {
        text-align: right;
      }

      can-copy {
        position: relative;
        cursor: pointer;
      }
      can-copy::after {
        background-color: #fff;
        color: #222;
        display: none;
        font-size: 12px;
        padding: 1px 2px;
        width: fit-content;
        border-radius: 1px;
        text-align: center;
        bottom: 120%;
        left: 0;
        box-shadow: 0 4px 14px 0 rgba(0,0,0,.2), 0 0 0 1px rgba(0,0,0,.05);
        position: absolute;
        white-space: nowrap;
        transition: .1s;
        content: 'Copy to clipboard';
      }
      can-copy:hover {
        text-decoration: underline;
        text-decoration-style: dotted;
      }
      can-copy:hover::after {
        display: block;
      }
      can-copy[copied]:hover::after {
        content: 'Copied!';
      }
    </style>
    <script>
      var report = {"file":"cmr2.exe","format":1,"timestamp":1756141401.0,"data":[{"address":"0x405626","name":"_mainCRTStartup","matching":0.23809523809523808,"recomp":"0x40125c","diff":[["@@ -0x405626,61 +0x40125c,65 @@",[{"both":[["0x405626","push ebp","0x40125c"],["0x405627","mov ebp, esp","0x40125d"],["0x405629","push -1","0x40125f"]]},{"orig":[["0x40562b","push 0x5112d0"],["0x405630","push 0x4057b0"]],"recomp":[["0x401261","push <OFFSET1>"],["0x401266","push __except_handler3 (UNK)"]]},{"both":[["0x405635","mov eax, dword ptr fs:[0]","0x40126b"],["0x40563b","push eax","0x401271"],["0x40563c","mov dword ptr fs:[0], esp","0x401272"]]},{"orig":[["0x405643","sub esp, 0x68"]],"recomp":[["0x401279","sub esp, 0x10"]]},{"both":[["0x405646","push ebx","0x40127c"],["0x405647","push esi","0x40127d"],["0x405648","push edi","0x40127e"],["0x405649","mov dword ptr [ebp - 0x18], esp","0x40127f"]]},{"orig":[["0x40564c","xor ebx, ebx"],["0x40564e","mov dword ptr [ebp - 4], ebx"],["0x405651","push 2"],["0x405653","call dword ptr [->MSVCRT.dll::__set_app_type (IMPORT)]"]],"recomp":[["0x401282","call dword ptr [->KERNEL32.dll::GetVersion (IMPORT)]"],["0x401288","xor edx, edx"],["0x40128a","mov dl, ah"],["0x40128c","mov dword ptr [__winminor (UNK)], edx"],["0x401292","mov ecx, eax"],["0x401294","and ecx, 0xff"],["0x40129a","mov dword ptr [__winmajor (UNK)], ecx"],["0x4012a0","shl ecx, 8"],["0x4012a3","add ecx, edx"],["0x4012a5","mov dword ptr [__winver (UNK)], ecx"],["0x4012ab","shr eax, 0x10"],["0x4012ae","mov dword ptr [__osver (UNK)], eax"],["0x4012b3","push 0"],["0x4012b5","call __heap_init (UNK)"]]},{"both":[["0x405659","pop ecx","0x4012ba"]]},{"orig":[["0x40565a","or dword ptr [<OFFSET2>], 0xffffffff"],["0x405661","or dword ptr [<OFFSET3>], 0xffffffff"],["0x405668","call dword ptr [->MSVCRT.dll::__p__fmode (IMPORT)]"],["0x40566e","mov ecx, dword ptr [<OFFSET5>]"],["0x405674","mov dword ptr [eax], ecx"],["0x405676","call dword ptr [->MSVCRT.dll::__p__commode (IMPORT)]"],["0x40567c","mov ecx, dword ptr [<OFFSET7>]"],["0x405682","mov dword ptr [eax], ecx"],["0x405684","mov eax, dword ptr [MSVCRT.dll::_adjust_fdiv (IMPORT)]"],["0x405689","mov eax, dword ptr [eax]"],["0x40568b","mov dword ptr [<OFFSET9>], eax"],["0x405690","call <OFFSET10>"],["0x405695","cmp dword ptr [<OFFSET11>], ebx"],["0x40569b","jne 0xc"],["0x40569d","push 0x4057a8"],["0x4056a2","call dword ptr [->MSVCRT.dll::__setusermatherr (IMPORT)]"]],"recomp":[["0x4012bb","test eax, eax"],["0x4012bd","jne 0x8"],["0x4012bf","push 0x1c"],["0x4012c1","call <OFFSET9>"]]},{"both":[["0x4056a8","pop ecx","0x4012c6"]]},{"orig":[["0x4056a9","call <OFFSET13>"],["0x4056ae","push 0x51601c"],["0x4056b3","push 0x516018"],["0x4056b8","call <OFFSET14>"],["0x4056bd","mov eax, dword ptr [<OFFSET15>]"],["0x4056c2","mov dword ptr [ebp - 0x6c], eax"],["0x4056c5","lea eax, [ebp - 0x6c]"]],"recomp":[["0x4012c7","and dword ptr [ebp - 4], 0"],["0x4012cb","call __ioinit (UNK)"],["0x4012d0","call dword ptr [->KERNEL32.dll::GetCommandLineA (IMPORT)]"],["0x4012d6","mov dword ptr [__acmdln (UNK)], eax"],["0x4012db","call ___crtGetEnvironmentStringsA (UNK)"],["0x4012e0","mov dword ptr [__aenvptr (UNK)], eax"],["0x4012e5","call __setargv (UNK)"],["0x4012ea","call __setenvp (UNK)"],["0x4012ef","call __cinit (UNK)"],["0x4012f4","mov eax, dword ptr [__environ (UNK)]"],["0x4012f9","mov dword ptr [___initenv (UNK)], eax"]]},{"both":[["0x4056c8","push eax","0x4012fe"]]},{"orig":[["0x4056c9","push dword ptr [<OFFSET16>]"],["0x4056cf","lea eax, [ebp - 0x64]"]],"recomp":[["0x4012ff","push dword ptr [___argv (UNK)]"],["0x401305","push dword ptr [___argc (UNK)]"],["0x40130b","call <OFFSET22>"],["0x401310","add esp, 0xc"],["0x401313","mov dword ptr [ebp - 0x1c], eax"]]},{"both":[["0x4056d2","push eax","0x401316"]]},{"orig":[["0x4056d3","lea eax, [ebp - 0x70]"]],"recomp":[["0x401317","call _exit (UNK)"],["0x40131c","mov eax, dword ptr [ebp - 0x14]"],["0x40131f","mov ecx, dword ptr [eax]"],["0x401321","mov ecx, dword ptr [ecx]"],["0x401323","mov dword ptr [ebp - 0x20], ecx"]]},{"both":[["0x4056d6","push eax","0x401326"]]},{"orig":[["0x4056d7","lea eax, [ebp - 0x60]"],["0x4056da","push eax"],["0x4056db","call dword ptr [->MSVCRT.dll::__getmainargs (IMPORT)]"],["0x4056e1","push 0x516014"],["0x4056e6","push 0x516000"],["0x4056eb","call <OFFSET14>"],["0x4056f0","add esp, 0x24"],["0x4056f3","mov eax, dword ptr [MSVCRT.dll::_acmdln (IMPORT)]"],["0x4056f8","mov esi, dword ptr [eax]"],["0x4056fa","mov dword ptr [ebp - 0x74], esi"],["0x4056fd","cmp byte ptr [esi], 0x22"],["0x405700","jne 0x3a"],["0x405702","inc esi"]],"recomp":[["0x401327","push ecx"],["0x401328","call __XcptFilter (UNK)"],["0x40132d","pop ecx"],["0x40132e","pop ecx"],["0x40132f","ret "],["0x401330","mov esp, dword ptr [ebp - 0x18]"],["0x401333","push dword ptr [ebp - 0x20]"],["0x401336","call __exit (UNK)"]]}]]]},{"address":"0x406910","name":"RallyDataCountryIndex","matching":0.46153846153846156,"recomp":"0x401090","diff":[["@@ -0x406910,7 +0x401090,6 @@",[{"orig":[],"recomp":[["0x401090","push ebp \t(RallyData.cpp:7)"],["0x401091","mov ebp, esp"]]},{"both":[["0x406910","mov eax, dword ptr [g_selectedRallyData (DATA)] \t(RallyData.cpp:8)","0x401093"],["0x406915","and eax, 0x1f","0x401098"]]},{"orig":[],"recomp":[["0x40109b","pop ebp \t(RallyData.cpp:9)"]]},{"both":[["0x406918","ret ","0x40109c"]]},{"orig":[["0x406919","nop "],["0x40691a","nop "],["0x40691b","nop "],["0x40691c","nop "]],"recomp":[]}]]]},{"address":"0x406930","name":"RallyDataStageIndex","matching":0.4,"recomp":"0x40109d","diff":[["@@ -0x406930,8 +0x40109d,7 @@",[{"orig":[],"recomp":[["0x40109d","push ebp \t(RallyData.cpp:12)"],["0x40109e","mov ebp, esp"]]},{"both":[["0x406930","mov eax, dword ptr [g_selectedRallyData (DATA)] \t(RallyData.cpp:13)","0x4010a0"]]},{"orig":[["0x406935","shr eax, 5"]],"recomp":[["0x4010a5","sar eax, 5"]]},{"both":[["0x406938","and eax, 0x1f","0x4010a8"]]},{"orig":[],"recomp":[["0x4010ab","pop ebp \t(RallyData.cpp:14)"]]},{"both":[["0x40693b","ret ","0x4010ac"]]},{"orig":[["0x40693c","nop "],["0x40693d","nop "],["0x40693e","nop "],["0x40693f","nop "]],"recomp":[]}]]]},{"address":"0x4074f0","name":"RallyDataState","matching":0.4,"recomp":"0x4010ad","diff":[["@@ -0x4074f0,8 +0x4010ad,7 @@",[{"orig":[],"recomp":[["0x4010ad","push ebp \t(RallyData.cpp:17)"],["0x4010ae","mov ebp, esp"]]},{"both":[["0x4074f0","mov eax, dword ptr [g_selectedRallyData (DATA)] \t(RallyData.cpp:18)","0x4010b0"]]},{"orig":[["0x4074f5","shr eax, 0xe"]],"recomp":[["0x4010b5","sar eax, 0xe"]]},{"both":[["0x4074f8","and eax, 3","0x4010b8"]]},{"orig":[],"recomp":[["0x4010bb","pop ebp \t(RallyData.cpp:19)"]]},{"both":[["0x4074fb","ret ","0x4010bc"]]},{"orig":[["0x4074fc","nop "],["0x4074fd","nop "],["0x4074fe","nop "],["0x4074ff","nop "]],"recomp":[]}]]]},{"address":"0x40d100","name":"RallyTiming_ResetOverallPlayerTimes","matching":0.046511627906976744,"recomp":"0x401102","diff":[["@@ -0x40d100,22 +0x401102,21 @@",[{"orig":[["0x40d100","xor eax, eax"],["0x40d102","mov ecx, g_rallyOverallTimesRaw[0] (DATA)"],["0x40d107","mov dword ptr [ecx], 0"],["0x40d10d","mov byte ptr [eax + g_rallyOverallOrderDriverID[0] (DATA)], al"],["0x40d113","add ecx, 4"],["0x40d116","inc eax"],["0x40d117","cmp ecx, g_rallyOverallTimesRaw[16] (UNK)"],["0x40d11d","jl -0x18"]],"recomp":[["0x401102","push ebp \t(RallyTiming.cpp:21)"],["0x401103","mov ebp, esp"],["0x401105","sub esp, 8"],["0x401108","mov dword ptr [ebp - 8], 0 \t(RallyTiming.cpp:22)"],["0x40110f","mov dword ptr [ebp - 4], g_rallyOverallTimesRaw[0] (DATA) \t(RallyTiming.cpp:23)"],["0x401116","mov eax, dword ptr [ebp - 4] \t(RallyTiming.cpp:26)"],["0x401119","mov dword ptr [eax], 0"],["0x40111f","mov ecx, dword ptr [ebp - 8] \t(RallyTiming.cpp:27)"],["0x401122","mov dl, byte ptr [ebp - 8]"],["0x401125","mov byte ptr [ecx + g_rallyOverallOrderDriverID[0] (DATA)], dl"],["0x40112b","mov eax, dword ptr [ebp - 4] \t(RallyTiming.cpp:28)"],["0x40112e","add eax, 4"],["0x401131","mov dword ptr [ebp - 4], eax"],["0x401134","mov ecx, dword ptr [ebp - 8] \t(RallyTiming.cpp:29)"],["0x401137","add ecx, 1"],["0x40113a","mov dword ptr [ebp - 8], ecx"],["0x40113d","cmp dword ptr [ebp - 4], 0x533698 \t(RallyTiming.cpp:30)"],["0x401144","jb -0x30"],["0x401146","mov esp, ebp \t(RallyTiming.cpp:31)"],["0x401148","pop ebp"]]},{"both":[["0x40d11f","ret ","0x401149"]]},{"orig":[["0x40d120","mov eax, dword ptr [esp + 8]"],["0x40d124","mov edx, dword ptr [esp + 4]"],["0x40d128","push ebx"],["0x40d129","push ebp"],["0x40d12a","push esi"],["0x40d12b","push edi"],["0x40d12c","mov edi, dword ptr [esp + 0x1c]"],["0x40d130","sub edx, eax"],["0x40d132","mov esi, 0x10"],["0x40d137","movsx ecx, byte ptr [edx + eax]"],["0x40d13b","movsx ebx, byte ptr [eax]"],["0x40d13e","mov ebp, dword ptr [ecx*4 + g_rallyOverallTimesRaw[0] (DATA)]"],["0x40d145","mov ebx, dword ptr [edi + ebx*4]"]],"recomp":[]}]]]},{"address":"0x40d390","name":"RallyTiming_GetOverallPositionDriverID","matching":0.36363636363636365,"recomp":"0x4010d0","diff":[["@@ -0x40d390,5 +0x4010d0,6 @@",[{"orig":[["0x40d390","mov eax, dword ptr [esp + 4]"]],"recomp":[["0x4010d0","push ebp \t(RallyTiming.cpp:10)"],["0x4010d1","mov ebp, esp"],["0x4010d3","mov eax, dword ptr [ebp + 8] \t(RallyTiming.cpp:11)"]]},{"both":[["0x40d394","movsx eax, byte ptr [eax + g_rallyOverallOrderDriverID[0] (DATA)]","0x4010d6"]]},{"orig":[],"recomp":[["0x4010dd","pop ebp \t(RallyTiming.cpp:12)"]]},{"both":[["0x40d39b","ret 4","0x4010de"]]},{"orig":[["0x40d39e","nop "],["0x40d39f","nop "]],"recomp":[]}]]]},{"address":"0x40d3b0","name":"RallyTiming_GetOverallTimeForPosition","matching":0.09090909090909091,"recomp":"0x4010e1","diff":[["@@ -0x40d3b0,11 +0x4010e1,11 @@",[{"orig":[["0x40d3b0","mov eax, dword ptr [esp + 4]"],["0x40d3b4","movsx eax, byte ptr [eax + g_rallyOverallOrderDriverID[0] (DATA)]"],["0x40d3bb","mov ecx, dword ptr [eax*4 + g_rallyOverallTimesRaw[0] (DATA)]"]],"recomp":[["0x4010e1","push ebp \t(RallyTiming.cpp:15)"],["0x4010e2","mov ebp, esp"]]},{"both":[["0x40d3c2","push ecx","0x4010e4"]]},{"orig":[["0x40d3c3","call <OFFSET3>"],["0x40d3c8","ret 4"],["0x40d3cb","nop "],["0x40d3cc","nop "],["0x40d3cd","nop "],["0x40d3ce","nop "],["0x40d3cf","nop "]],"recomp":[["0x4010e5","mov eax, dword ptr [ebp + 8] \t(RallyTiming.cpp:16)"],["0x4010e8","movsx ecx, byte ptr [eax + g_rallyOverallOrderDriverID[0] (DATA)]"],["0x4010ef","mov edx, dword ptr [ecx*4 + g_rallyOverallTimesRaw[0] (DATA)]"],["0x4010f6","mov dword ptr [ebp - 4], edx"],["0x4010f9","mov eax, 0x898 \t(RallyTiming.cpp:17)"],["0x4010fe","mov esp, ebp \t(RallyTiming.cpp:18)"],["0x401100","pop ebp"],["0x401101","ret "]]}]]]},{"address":"0x455cf0","name":"StageTiming_GetTimeForPosition","matching":0.23076923076923078,"recomp":"0x401180","diff":[["@@ -0x455cf0,14 +0x401180,12 @@",[{"orig":[["0x455cf0","call GetStageSplitCount (FUNCTION)"],["0x455cf5","mov ecx, dword ptr [esp + 4]"]],"recomp":[["0x401180","push ebp \t(StageTiming.cpp:9)"],["0x401181","mov ebp, esp"],["0x401183","push ecx"],["0x401184","call <OFFSET1> \t(StageTiming.cpp:10)"],["0x401189","mov dword ptr [ebp - 4], eax"],["0x40118c","mov eax, dword ptr [ebp - 4] \t(StageTiming.cpp:14)"]]},{"both":[["0x455cf9","shl eax, 4","0x40118f"]]},{"orig":[],"recomp":[["0x401192","mov ecx, dword ptr [ebp + 8]"]]},{"both":[["0x455cfc","movsx eax, byte ptr [eax + ecx + g_stageSplitDriverIndices[0].[0] (DATA)]","0x401195"]]},{"orig":[],"recomp":[["0x40119d","mov esp, ebp \t(StageTiming.cpp:15)"],["0x40119f","pop ebp"]]},{"both":[["0x455d04","ret 4","0x4011a0"]]},{"orig":[["0x455d07","nop "],["0x455d08","nop "],["0x455d09","nop "],["0x455d0a","nop "],["0x455d0b","nop "],["0x455d0c","nop "],["0x455d0d","nop "],["0x455d0e","nop "],["0x455d0f","nop "]],"recomp":[]}]]]},{"address":"0x4583c0","name":"GetStageSplitCount","matching":0.36363636363636365,"recomp":"0x401170","diff":[["@@ -0x4583c0,6 +0x401170,5 @@",[{"orig":[],"recomp":[["0x401170","push ebp \t(Stage.cpp:9)"],["0x401171","mov ebp, esp"]]},{"both":[["0x4583c0","movsx eax, byte ptr [g_stageSplitCount (DATA)] \t(Stage.cpp:10)","0x401173"]]},{"orig":[],"recomp":[["0x40117a","pop ebp \t(Stage.cpp:11)"]]},{"both":[["0x4583c7","ret ","0x40117b"]]},{"orig":[["0x4583c8","nop "],["0x4583c9","nop "],["0x4583ca","nop "],["0x4583cb","nop "]],"recomp":[]}]]]},{"address":"0x4de170","name":"FormatCentisecondsAsMinSecMSec","matching":0.17543859649122806,"recomp":"0x4011b0","diff":[["@@ -0x4de170,28 +0x4011b0,29 @@",[{"orig":[["0x4de170","mov ecx, dword ptr [esp + 4]"],["0x4de174","push esi"],["0x4de175","mov eax, ecx"],["0x4de177","mov esi, 0x64"]],"recomp":[["0x4011b0","push ebp \t(TimingUtils.cpp:6)"],["0x4011b1","mov ebp, esp"],["0x4011b3","mov eax, dword ptr [ebp + 8] \t(TimingUtils.cpp:7)"]]},{"both":[["0x4de17c","cdq ","0x4011b6"]]},{"orig":[["0x4de17d","idiv esi"],["0x4de17f","mov eax, ecx"],["0x4de181","mov esi, 0x1770"]],"recomp":[["0x4011b7","mov ecx, 0x64"],["0x4011bc","idiv ecx"]]},{"both":[["0x4de186","push edx","0x4011be"]]},{"orig":[],"recomp":[["0x4011bf","mov eax, dword ptr [ebp + 8]"]]},{"both":[["0x4de187","cdq ","0x4011c2"]]},{"orig":[["0x4de188","idiv esi"],["0x4de18a","mov eax, 0x51eb851f"],["0x4de18f","imul edx"],["0x4de191","sar edx, 5"]],"recomp":[["0x4011c3","mov ecx, 0x1770"],["0x4011c8","idiv ecx"]]},{"both":[["0x4de194","mov eax, edx","0x4011ca"]]},{"orig":[["0x4de196","shr eax, 0x1f"],["0x4de199","add edx, eax"],["0x4de19b","mov eax, 0x57619f1"]],"recomp":[["0x4011cc","cdq "],["0x4011cd","mov ecx, 0x64"],["0x4011d2","idiv ecx"],["0x4011d4","push eax"],["0x4011d5","mov eax, dword ptr [ebp + 8]"],["0x4011d8","cdq "],["0x4011d9","mov ecx, 0x1770"],["0x4011de","idiv ecx"],["0x4011e0","push eax"],["0x4011e1","mov edx, dword ptr [g_minSecMSECFormatString (DATA)]"]]},{"both":[["0x4de1a0","push edx","0x4011e7"]]},{"orig":[["0x4de1a1","imul ecx"],["0x4de1a3","sar edx, 7"],["0x4de1a6","mov ecx, edx"],["0x4de1a8","shr ecx, 0x1f"],["0x4de1ab","add edx, ecx"],["0x4de1ad","push edx"],["0x4de1ae","mov edx, dword ptr [esp + 0x18]"],["0x4de1b2","push 0x519f58"],["0x4de1b7","push edx"]],"recomp":[["0x4011e8","mov eax, dword ptr [ebp + 0xc]"],["0x4011eb","push eax"],["0x4011ec","call _sprintf (UNK)"],["0x4011f1","add esp, 0x14"],["0x4011f4","pop ebp \t(TimingUtils.cpp:8)"],["0x4011f5","ret 8"]]}]]]}]};
      var data = report["data"];
    </script>
    <script>// reccmp.js
/* global data */

// Unwrap array of functions into a dictionary with address as the key.
const dataDict = Object.fromEntries(data.map((row) => [row.address, row]));

function getDataByAddr(addr) {
  return dataDict[addr];
}

//
// Pure functions
//

function formatAsm(entries, _addrOption) {
  const output = [];

  const createTh = (text) => {
    const th = document.createElement('th');
    th.innerText = text;
    return th;
  };

  const createTd = (text, className = '') => {
    const td = document.createElement('td');
    td.innerText = text;
    td.className = className;
    return td;
  };

  entries.forEach((obj) => {
    // These won't all be present. You get "both" for an equal node
    // and orig/recomp for a diff.
    const { both = [], orig = [], recomp = [] } = obj;

    output.push(
      ...both.map(([addr, line, recompAddr]) => {
        const tr = document.createElement('tr');
        tr.appendChild(createTh(addr));
        tr.appendChild(createTh(recompAddr));
        tr.appendChild(createTd(line));
        return tr;
      }),
    );

    output.push(
      ...orig.map(([addr, line]) => {
        const tr = document.createElement('tr');
        tr.appendChild(createTh(addr));
        tr.appendChild(createTh(''));
        tr.appendChild(createTd(`-${line}`, 'diffneg'));
        return tr;
      }),
    );

    output.push(
      ...recomp.map(([addr, line]) => {
        const tr = document.createElement('tr');
        tr.appendChild(createTh(''));
        tr.appendChild(createTh(addr));
        tr.appendChild(createTd(`+${line}`, 'diffpos'));
        return tr;
      }),
    );
  });

  return output;
}

// Special internal values to ensure this sort order for matching column:
// 1. Stub
// 2. Any match percentage [0.0, 1.0)
// 3. Effective match
// 4. Actual 100% match
function matchingColAdjustment(row) {
  if ('stub' in row) {
    return -1;
  }

  if ('effective' in row) {
    return 1.0;
  }

  if (row.matching === 1.0) {
    return 1000;
  }

  return row.matching;
}

function getCppClass(str) {
  const idx = str.indexOf('::');
  if (idx !== -1) {
    return str.slice(0, idx);
  }

  return str;
}

// Clamp string length to specified length and pad with ellipsis
function stringTruncate(str, maxlen = 20) {
  str = getCppClass(str);
  if (str.length > maxlen) {
    return `${str.slice(0, maxlen)}...`;
  }

  return str;
}

function getMatchPercentText(row) {
  if ('stub' in row) {
    return 'stub';
  }

  if ('effective' in row) {
    return '100.00%*';
  }

  return `${(row.matching * 100).toFixed(2)}%`;
}

function countDiffs(row) {
  const { diff = '' } = row;
  if (diff === '') {
    return '';
  }

  const diffs = diff.flatMap(([_slug, subgroups]) => subgroups);
  const diffLength = diffs.filter((d) => !('both' in d)).length;
  const diffWord = diffLength === 1 ? 'diff' : 'diffs';
  return diffLength === 0 ? '' : `${diffLength} ${diffWord}`;
}

// Helper for this set/remove attribute block
function setBooleanAttribute(element, attribute, value) {
  if (value) {
    element.setAttribute(attribute, '');
  } else {
    element.removeAttribute(attribute);
  }
}

function copyToClipboard(value) {
  navigator.clipboard.writeText(value);
}

const PAGE_SIZE = 200;

//
// Global state
//

class ListingState {
  constructor() {
    this._query = '';
    this._sortCol = 'address';
    this._filterType = 1;
    this._sortDesc = false;
    this._hidePerfect = false;
    this._hideStub = false;
    this._showRecomp = false;
    this._expanded = {};
    this._page = 0;

    this._listeners = [];

    this._results = [];
    this.updateResults();
  }

  addListener(fn) {
    this._listeners.push(fn);
  }

  callListeners() {
    for (const fn of this._listeners) {
      fn();
    }
  }

  isExpanded(addr) {
    return addr in this._expanded;
  }

  toggleExpanded(addr) {
    this.setExpanded(addr, !this.isExpanded(addr));
  }

  setExpanded(addr, value) {
    if (value) {
      this._expanded[addr] = true;
    } else {
      delete this._expanded[addr];
    }
  }

  updateResults() {
    const filterFn = this.rowFilterFn.bind(this);
    const sortFn = this.rowSortFn.bind(this);

    this._results = data.filter(filterFn).sort(sortFn);

    // Set _page directly to avoid double call to listeners.
    this._page = this.pageClamp(this.page);
    this.callListeners();
  }

  pageSlice() {
    return this._results.slice(this.page * PAGE_SIZE, (this.page + 1) * PAGE_SIZE);
  }

  resultsCount() {
    return this._results.length;
  }

  pageCount() {
    return Math.ceil(this._results.length / PAGE_SIZE);
  }

  maxPage() {
    return Math.max(0, this.pageCount() - 1);
  }

  // A list showing the range of each page based on the sort column and direction.
  pageHeadings() {
    if (this._results.length === 0) {
      return [];
    }

    const headings = [];

    for (let i = 0; i < this.pageCount(); i++) {
      const startIdx = i * PAGE_SIZE;
      const endIdx = Math.min(this._results.length, (i + 1) * PAGE_SIZE) - 1;

      let start = this._results[startIdx][this.sortCol];
      let end = this._results[endIdx][this.sortCol];

      if (this.sortCol === 'matching') {
        start = getMatchPercentText(this._results[startIdx]);
        end = getMatchPercentText(this._results[endIdx]);
      }

      headings.push([i, stringTruncate(start), stringTruncate(end)]);
    }

    return headings;
  }

  rowFilterFn(row) {
    // Destructuring sets defaults for optional values from this object.
    const { effective = false, stub = false, diff = '', name, address, matching } = row;

    if (this.hidePerfect && (effective || matching >= 1)) {
      return false;
    }

    if (this.hideStub && stub) {
      return false;
    }

    if (this.query === '') {
      return true;
    }

    // Name/addr search
    if (this.filterType === 1) {
      return address.includes(this.query) || name.toLowerCase().includes(this.query);
    }

    // no diff for review.
    if (diff === '') {
      return false;
    }

    // special matcher for combined diff
    const anyLineMatch = ([_addr, line]) => line.toLowerCase().trim().includes(this.query);

    // Flatten all diff groups for the search
    const diffs = diff.flatMap(([_slug, subgroups]) => subgroups);
    for (const subgroup of diffs) {
      const { both = [], orig = [], recomp = [] } = subgroup;

      // If search includes context
      if (this.filterType === 2 && both.some(anyLineMatch)) {
        return true;
      }

      if (orig.some(anyLineMatch) || recomp.some(anyLineMatch)) {
        return true;
      }
    }

    return false;
  }

  rowSortFn(rowA, rowB) {
    const valA = this.sortCol === 'matching' ? matchingColAdjustment(rowA) : rowA[this.sortCol];

    const valB = this.sortCol === 'matching' ? matchingColAdjustment(rowB) : rowB[this.sortCol];

    if (valA > valB) {
      return this.sortDesc ? -1 : 1;
    } else if (valA < valB) {
      return this.sortDesc ? 1 : -1;
    }

    return 0;
  }

  pageClamp(page) {
    return Math.max(0, Math.min(page, this.maxPage()));
  }

  get page() {
    return this._page;
  }

  set page(page) {
    this._page = this.pageClamp(page);
    this.callListeners();
  }

  get filterType() {
    return parseInt(this._filterType);
  }

  set filterType(value) {
    value = parseInt(value);
    if (value >= 1 && value <= 3) {
      this._filterType = value;
    }
    this.updateResults();
  }

  get query() {
    return this._query;
  }

  set query(value) {
    // Normalize search string
    this._query = value.toLowerCase().trim();
    this.updateResults();
  }

  get showRecomp() {
    return this._showRecomp;
  }

  set showRecomp(value) {
    // Don't sort by the recomp column we are about to hide
    if (!value && this.sortCol === 'recomp') {
      this._sortCol = 'address';
    }

    this._showRecomp = value;
    this.callListeners();
  }

  get sortCol() {
    return this._sortCol;
  }

  set sortCol(column) {
    if (column === this._sortCol) {
      this._sortDesc = !this._sortDesc;
    } else {
      this._sortCol = column;
    }

    this.updateResults();
  }

  get sortDesc() {
    return this._sortDesc;
  }

  set sortDesc(value) {
    this._sortDesc = value;
    this.updateResults();
  }

  get hidePerfect() {
    return this._hidePerfect;
  }

  set hidePerfect(value) {
    this._hidePerfect = value;
    this.updateResults();
  }

  get hideStub() {
    return this._hideStub;
  }

  set hideStub(value) {
    this._hideStub = value;
    this.updateResults();
  }
}

const appState = new ListingState();

//
// Custom elements
//

// Sets sort indicator arrow based on element attributes.
class SortIndicator extends window.HTMLElement {
  static observedAttributes = ['data-sort'];

  attributeChangedCallback(_name, _oldValue, newValue) {
    if (newValue === null) {
      // Reserve space for blank indicator so column width stays the same
      this.innerHTML = '&nbsp;';
    } else {
      this.innerHTML = newValue === 'asc' ? '&#9650;' : '&#9660;';
    }
  }
}

class CanCopy extends window.HTMLElement {
  connectedCallback() {
    this.addEventListener('mouseout', () => {
      this.copied = false;
    });

    this.addEventListener('click', (evt) => {
      copyToClipboard(evt.target.textContent);
      this.copied = true;
    });
  }

  get copied() {
    return this.getAttribute('copied');
  }

  set copied(value) {
    if (value) {
      setTimeout(() => {
        this.copied = false;
      }, 2000);
    }
    setBooleanAttribute(this, 'copied', value);
  }
}

class DiffDisplayOptions extends window.HTMLElement {
  static observedAttributes = ['data-option'];

  connectedCallback() {
    if (this.shadowRoot !== null) {
      return;
    }

    const shadow = this.attachShadow({ mode: 'open' });
    shadow.innerHTML = `
      <style>
        fieldset {
          align-items: center;
          display: flex;
          margin-bottom: 20px;
        }

        label {
          margin-right: 10px;
          user-select: none;
        }

        label, input {
          cursor: pointer;
        }
      </style>
      <fieldset>
        <legend>Address display:</legend>
        <input type="radio" id="showNone" name="addrDisplay" value=0>
        <label for="showNone">None</label>
        <input type="radio" id="showOrig" name="addrDisplay" value=1>
        <label for="showOrig">Original</label>
        <input type="radio" id="showBoth" name="addrDisplay" value=2>
        <label for="showBoth">Both</label>
      </fieldset>`;

    shadow.querySelectorAll('input[type=radio]').forEach((radio) => {
      const checked = this.option === radio.getAttribute('value');
      setBooleanAttribute(radio, 'checked', checked);

      radio.addEventListener('change', (evt) => {
        this.option = evt.target.value;
      });
    });
  }

  set option(value) {
    this.setAttribute('data-option', parseInt(value));
  }

  get option() {
    return this.getAttribute('data-option') ?? 1;
  }

  attributeChangedCallback(name, _oldValue, _newValue) {
    if (name !== 'data-option') {
      return;
    }

    this.dispatchEvent(new Event('change'));
  }
}

class DiffDisplay extends window.HTMLElement {
  static observedAttributes = ['data-option'];

  connectedCallback() {
    if (this.querySelector('diff-display-options') !== null) {
      return;
    }

    const optControl = new DiffDisplayOptions();
    optControl.option = this.option;
    optControl.addEventListener('change', (evt) => {
      this.option = evt.target.option;
    });
    this.appendChild(optControl);

    const div = document.createElement('div');
    const obj = getDataByAddr(this.address);

    const createHeaderLine = (text, className) => {
      const div = document.createElement('div');
      div.textContent = text;
      div.className = className;
      return div;
    };

    const groups = obj.diff;
    groups.forEach(([slug, subgroups]) => {
      const secondTable = document.createElement('table');
      secondTable.classList.add('diffTable');

      const hdr = document.createElement('div');
      hdr.appendChild(createHeaderLine('---', 'diffneg'));
      hdr.appendChild(createHeaderLine('+++', 'diffpos'));
      hdr.appendChild(createHeaderLine(slug, 'diffslug'));
      div.appendChild(hdr);

      const tbody = document.createElement('tbody');
      secondTable.appendChild(tbody);

      const diffs = formatAsm(subgroups, this.option);
      for (const el of diffs) {
        tbody.appendChild(el);
      }

      div.appendChild(secondTable);
    });

    this.appendChild(div);
  }

  get address() {
    return this.getAttribute('data-address');
  }

  set address(value) {
    this.setAttribute('data-address', value);
  }

  get option() {
    return this.getAttribute('data-option') ?? 1;
  }

  set option(value) {
    this.setAttribute('data-option', value);
  }
}

class ListingOptions extends window.HTMLElement {
  constructor() {
    super();

    // Register to receive updates
    appState.addListener(() => this.onUpdate());

    const input = this.querySelector('input[type=search]');
    input.oninput = (evt) => {
      appState.query = evt.target.value;
    };

    const hidePerf = this.querySelector('input#cbHidePerfect');
    hidePerf.onchange = (evt) => {
      appState.hidePerfect = evt.target.checked;
    };
    hidePerf.checked = appState.hidePerfect;

    const hideStub = this.querySelector('input#cbHideStub');
    hideStub.onchange = (evt) => {
      appState.hideStub = evt.target.checked;
    };
    hideStub.checked = appState.hideStub;

    const showRecomp = this.querySelector('input#cbShowRecomp');
    showRecomp.onchange = (evt) => {
      appState.showRecomp = evt.target.checked;
    };
    showRecomp.checked = appState.showRecomp;

    this.querySelector('button#pagePrev').addEventListener('click', () => {
      appState.page = appState.page - 1;
    });

    this.querySelector('button#pageNext').addEventListener('click', () => {
      appState.page = appState.page + 1;
    });

    this.querySelector('select#pageSelect').addEventListener('change', (evt) => {
      appState.page = evt.target.value;
    });

    this.querySelectorAll('input[name=filterType]').forEach((radio) => {
      const checked = appState.filterType === parseInt(radio.getAttribute('value'));
      radio.checked = checked;

      radio.onchange = () => {
        appState.filterType = radio.getAttribute('value');
      };
    });

    this.onUpdate();
  }

  onUpdate() {
    // Update input placeholder based on search type
    this.querySelector('input[type=search]').placeholder =
      appState.filterType === 1 ? 'Search for offset or function name...' : 'Search for instruction...';

    // Update page number and max page
    this.querySelector('fieldset#pageDisplay > legend').textContent =
      `Page ${appState.page + 1} of ${Math.max(1, appState.pageCount())}`;

    // Disable prev/next buttons on first/last page
    setBooleanAttribute(this.querySelector('button#pagePrev'), 'disabled', appState.page === 0);
    setBooleanAttribute(this.querySelector('button#pageNext'), 'disabled', appState.page === appState.maxPage());

    // Update page select dropdown
    const pageSelect = this.querySelector('select#pageSelect');
    setBooleanAttribute(pageSelect, 'disabled', appState.resultsCount() === 0);
    pageSelect.innerHTML = '';

    if (appState.resultsCount() === 0) {
      const opt = document.createElement('option');
      opt.textContent = '- no results -';
      pageSelect.appendChild(opt);
    } else {
      for (const row of appState.pageHeadings()) {
        const opt = document.createElement('option');
        opt.value = row[0];
        if (appState.page === row[0]) {
          opt.setAttribute('selected', '');
        }

        const [start, end] = [row[1], row[2]];

        opt.textContent = `${appState.sortCol}: ${start} to ${end}`;
        pageSelect.appendChild(opt);
      }
    }

    // Update row count
    this.querySelector('#rowcount').textContent = `${appState.resultsCount()}`;
  }
}

// Main application.
class ListingTable extends window.HTMLElement {
  constructor() {
    super();

    // Register to receive updates
    appState.addListener(() => this.somethingChanged());
  }

  diffRow(address, showRecomp) {
    const obj = getDataByAddr(address);

    let contents;

    if ('stub' in obj) {
      contents = document.createElement('div');
      contents.setAttribute('class', 'no-diff');
      contents.textContent = 'Stub. No diff.';
    } else if (obj.diff.length === 0) {
      contents = document.createElement('div');
      contents.setAttribute('class', 'no-diff');
      contents.textContent = 'Identical function - no diff';
    } else {
      contents = document.createElement('diff-display');
      contents.setAttribute('data-option', '1');
      contents.setAttribute('data-address', address);
    }

    const td = document.createElement('td');
    td.setAttribute('colspan', showRecomp ? 5 : 4);
    td.append(contents);

    const tr = document.createElement('tr');
    tr.setAttribute('data-diff', address);
    tr.append(td);
    return tr;
  }

  funcRow(obj, showRecomp) {
    const createColumn = (dataCol, canCopy, textContent) => {
      const td = document.createElement('td');
      td.setAttribute('data-col', dataCol);
      if (canCopy) {
        const copy = document.createElement('can-copy');
        copy.textContent = textContent;
        td.append(copy);
      } else {
        td.append(textContent);
      }

      return td;
    };

    const cols = {
      address: createColumn('address', true, obj.address),
      recomp: createColumn('recomp', true, obj.recomp),
      name: createColumn('name', false, obj.name),
      diffs: createColumn('diffs', false, countDiffs(obj)),
      matching: createColumn('matching', false, getMatchPercentText(obj)),
    };

    if (!showRecomp) {
      delete cols.recomp;
    }

    const tr = document.createElement('tr');
    tr.setAttribute('data-address', obj.address);
    tr.append(...Object.values(cols));
    return tr;
  }

  headerRow(showRecomp, sortCol, sortDesc) {
    const cols = {
      address: 'Address',
      recomp: 'Recomp',
      name: 'Name',
      diffs: '',
      matching: 'Matching',
    };

    if (!showRecomp) {
      delete cols.recomp;
    }

    const headers = Object.entries(cols).map(([key, name]) => {
      if (key === 'diffs') {
        const th = document.createElement('th');
        th.setAttribute('data-col', 'diffs');
        th.setAttribute('data-no-sort', true);
        return th;
      }

      const sort_indicator = document.createElement('sort-indicator');
      if (key === sortCol) {
        sort_indicator.setAttribute('data-sort', sortDesc ? 'desc' : 'asc');
      }

      const th = document.createElement('th');
      th.setAttribute('data-col', key);
      const div = document.createElement('div');
      const span = document.createElement('span');
      span.textContent = name;
      div.append(span, sort_indicator);
      th.append(div);
      return th;
    });

    const tr = document.createElement('tr');
    tr.append(...headers);
    return tr;
  }

  setDiffRow(address, shouldExpand) {
    const tbody = this.querySelector('tbody');
    const funcrow = tbody.querySelector(`tr[data-address="${address}"]`);
    if (funcrow === null) {
      return;
    }

    const existing = tbody.querySelector(`tr[data-diff="${address}"]`);
    if (existing !== null) {
      if (!shouldExpand) {
        tbody.removeChild(existing);
      }

      return;
    }

    // Insert the diff row after the parent func row.
    funcrow.insertAdjacentElement('afterend', this.diffRow(address, appState.showRecomp));
  }

  connectedCallback() {
    this.addEventListener('name-click', (evt) => {
      appState.toggleExpanded(evt.detail);
      this.setDiffRow(evt.detail, appState.isExpanded(evt.detail));
    });

    this.innerHTML = '<table id="listing"><thead></thead><tbody></tbody></table>';

    this.somethingChanged();
  }

  somethingChanged() {
    const header_row = this.headerRow(appState.showRecomp, appState.sortCol, appState.sortDesc);

    const rows = [];

    // Create rows for this page.
    for (const obj of appState.pageSlice()) {
      rows.push(this.funcRow(obj, appState.showRecomp));
      if (appState.isExpanded(obj.address)) {
        rows.push(this.diffRow(obj.address, appState.showRecomp));
      }
    }

    this.querySelector('thead').replaceChildren(header_row);
    this.querySelector('tbody').replaceChildren(...rows);

    this.querySelectorAll('th:not([data-no-sort])').forEach((th) => {
      const col = th.getAttribute('data-col');
      if (col) {
        const span = th.querySelector('span');
        if (span) {
          span.addEventListener('click', () => {
            appState.sortCol = col;
          });
        }
      }
    });

    this.querySelectorAll('tr[data-address]').forEach((row) => {
      // Clicking the name column toggles the diff detail row.
      // This is added or removed without replacing the entire <tbody>.
      row.querySelector('td[data-col="name"]').addEventListener('click', () => {
        this.dispatchEvent(new CustomEvent('name-click', { detail: row.getAttribute('data-address') }));
      });
    });
  }
}

window.onload = () => {
  window.customElements.define('listing-table', ListingTable);
  window.customElements.define('listing-options', ListingOptions);
  window.customElements.define('diff-display', DiffDisplay);
  window.customElements.define('diff-display-options', DiffDisplayOptions);
  window.customElements.define('sort-indicator', SortIndicator);
  window.customElements.define('can-copy', CanCopy);
};
</script>
    </script>
  </head>
  <body>
    <div class="main">
      <h1>Decompilation Status</h1>
      <listing-options>
        <input id="search" type="search" placeholder="Search for offset or function name...">
        <div class="filters">
          <fieldset>
            <legend>Options:</legend>
            <input type="checkbox" id="cbHidePerfect" />
            <label for="cbHidePerfect">Hide 100% match</label>
            <input type="checkbox" id="cbHideStub" />
            <label for="cbHideStub">Hide stubs</label>
            <input type="checkbox" id="cbShowRecomp" />
            <label for="cbShowRecomp">Show recomp address</label>
          </fieldset>
          <fieldset>
            <legend>Search filters on:</legend>
            <input type="radio" name="filterType" id="filterName" value=1 checked />
            <label for="filterName">Name/address</label>
            <input type="radio" name="filterType" id="filterAsm" value=2 />
            <label for="filterAsm">Asm output</label>
            <input type="radio" name="filterType" id="filterDiff" value=3 />
            <label for="filterDiff">Asm diffs only</label>
          </fieldset>
        </div>
        <div class="filters">
          <p class="rowcount">Results: <span id="rowcount"></span></p>
          <fieldset id="pageDisplay">
            <legend>Page</legend>
            <button id="pagePrev">prev</button>
            <select id="pageSelect">
            </select>
            <button id="pageNext">next</button>
          </fieldset>
        </div>
      </listing-options>
      <listing-table>
      </listing-table>
    </div>
  </body>
</html>
